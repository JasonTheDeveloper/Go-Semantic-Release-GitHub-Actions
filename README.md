# Go + Semantic-Release + GitHub Actions

[![build](https://github.com/JasonTheDeveloper/Go-Semantic-Release-GitHub-Actions/workflows/build/badge.svg?branch=master)](https://github.com/JasonTheDeveloper/Go-Semantic-Release-GitHub-Actions/actions?query=workflow%3Abuild) [![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)

This project is purely meant to serve as an example of how you could use [DevContainers](https://code.visualstudio.com/docs/remote/containers) for development, [semantic-release](https://github.com/semantic-release/semantic-release) to manage releases, and [GitHub Actions](https://github.com/features/actions) for testing/building go targeting different architectures.

## DevContainers

[DevContainers](https://code.visualstudio.com/docs/remote/containers) are terrific for getting other contributors up and running with little hassle. DevContainers takes the headache away from having to setup your development environment and ensures everyone on your team, contributing to the project all have the same setup regardless of their operating system and what dependencies they're missing.

And because DevContainers are containerised, if anything happens and you need to destroy and recreate your environment, you can with a click of a button!

There are a couple things you need in order to run the DevContainer and they are:

- [Visual Studio Code](https://code.visualstudio.com/)
- [Remote Development](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack)
- [Docker](https://docs.docker.com/install/)

A full DevContainer setup guide can be found [here](https://code.visualstudio.com/docs/remote/containers#_getting-started).

The DevContainer in this repository is configured specifically for Go and installs additional packages and Visual Studio Code extensions to make developing Go a bit nicer.

Sample DevContainers for other languages can be found [here](https://github.com/microsoft/vscode-dev-containers/tree/master/containers).

## Why semantic-release?

[Semantic-release](https://github.com/semantic-release/semantic-release) is a great tool, standalone tool for managing versioning and release of packages/binaries. Semantic-release is responsible for generating change logs, increasing the semantic version, and creating new releases in GitHub.

### GoReleaser vs. semantic-release

[GoReleaser](https://github.com/goreleaser/goreleaser) is another tool that could have been used over semantic-release. It generates go binaries for several platforms, it also creates a new GitHub release but on top of that, GoReleaser also pushes a HomeBrew formula to a tap repository!

So why not GoReleaser? A couple reasons.

1. The release notes are not formatted as they are with semantic-release.
2. GoReleaser does not commit a `CHANGELOG.md` back to the repo.
3. It appears GoReleaser only works with Go projects, while semantic-release can work regardless of the underlining language as it's git commit based.

Putting aside the fact this repository uses go as an example project, with some minor tweaks, the configurations used for semantic-release in this repository can be transferred and applied to any project regardless of programming language.

### GitHub Release

Semantic-release was chosen for creating new GitHub releases over other actions like [Create Release](https://github.com/marketplace/actions/create-release) because semantic-release is smart enough to only include changes that happened between releases automatically.

Sure, with [Create Release](https://github.com/marketplace/actions/create-release) you can point to the `CHANGELOG.md` generated by semantic-release and use that for the body, but the way semantic-release generates the `CHANGELOG.md`, your body will have the complete changelog history in the release which is not very ideal.

## GitHub Actions

In this repository theres one GitHub Action [workflow](.github/workflows/example_build.yaml) setup to lint, test, build and release the example project.

Looking at the [workflow](.github/workflows/example_build.yaml), linting, testing/building and release are separated into their own jobs.

Firstly, `lint` and `test` run in parallel. `test` runs on `ubuntu-latest`, `macos-latest`, and `windows-latest`, building and testing on Go version `1.12.x` and `1.13.x`. If all jobs complete successfully, the `release` job is then triggered.

The reason `lint` isn't apart of the `test` job is because we don't need to worry about whether the project is lintted correctly on different operating systems as linting is more to do with coding styles which is not affected by the system you're running.

More information about using GitHub Actions can be found [here](https://help.github.com/en/actions).
