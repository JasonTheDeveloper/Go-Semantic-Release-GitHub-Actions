# Go + Semantic-Release + GitHub Actions

![Example Build](https://github.com/JasonTheDeveloper/Go-Semantic-Release-GitHub-Actions/workflows/build/badge.svg?branch=master) [![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)

This project is purely meant to serve as an example of how you could use [DevContainers](https://code.visualstudio.com/docs/remote/containers) for development, [semantic-release](https://github.com/semantic-release/semantic-release) to manage releases, and [GitHub Actions](https://github.com/features/actions) for testing/building go targeting different architectures.

## Why Semantic-Release?

Semantic-release is a great tool, standalone tool for managing versioning and release of packages/binaries. Semantic-release is responsible for generating change logs, increasing the semantic version, and creating new releases in GitHub.

### GoReleaser vs. semantic-release

[GoReleaser](https://github.com/goreleaser/goreleaser) is another tool that could have been used over semantic-release. It generates go binaries for several platforms, it also creates a new GitHub release but on top of that, GoReleaser also pushes a HomeBrew formula to a tap repository!

So why not GoReleaser? A couple reasons.

1. The release notes are not formatted as they are with semantic-release.
2. GoReleaser does not commit a `CHANGELOG.md` back to the repo.
3. It appears GoReleaser only works with Go projects, while semantic-release can work regardless of the underlining language as it's git commit based.

### GitHub Release

Semantic-release was chosen for creating new GitHub releases over other actions like [Create Release](https://github.com/marketplace/actions/create-release) because semantic-release is smart enough to only include changes that happened between releases automatically.

Sure, with [Create Release](https://github.com/marketplace/actions/create-release) you can point to the `CHANGELOG.md` generated by semantic-release and use that for the body, but the way semantic-release generates the `CHANGELOG.md`, your body will have the complete changelog history in the release which is not very ideal.
